# EIP

1과목
-

GoF(Gang of Four) : 소프트웨어 설계에 있어 공통된 문제들에 대한 표준적인 해법과 작명법을 제안한 책

1. 생성 패턴 : 객체 생성에 대한 패턴 ㅍㅊㅍㅄ
- 추상 팩토리
- 빌더
- 팩토리 메소드 : Virtual-Constructor 패턴이라고도함
- 프로토타입
- 싱글턴

2. 구조패턴 : 구조가 복잡한 시스템 개발에 도움을 줌
- 어댑터
- 브릿지
- 합성
- 데코레이터
- 파사드
- 플라이웨이트
- 프록시

3. 행동 패턴 : 상호작용이나 책임 분배에 대한 부분을 정의하고 결합도는 최소화 하는 것이 목표
- 책임 연쇄
- 커맨드
- 인터프리터
- 반복자
- 중재자
- 메멘토
- 옵저버
- 상태
- 전략
- 템플릿 메소드
- 방문자

4. 디자인 패턴 : 설계에서 자주 발생하는 문제에 대한 일반적이고 반복적인 해결 방법
- 소프트웨어 구조 파악이 용이하다.
- 객체지량 설계 및 구현의 생산성을 높이는데 적합하다.
- 재사용을 위한 개발 시간이 단축된다.
- 소프트웨어 코드의 품질을 향상시킬 수 있따.
- 개발 프로세스를 무시할 수 있따.
- 소프트웨어의 품질과 생산성을 향상시킬 수 있다.
- 디자인 패턴을 목적으로 분류할 때 생성, 구조, 행위로 분류할 수 있따.
- 행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.



클래스
: 객체지향 프로그램에서 데이터를 추상화하는 단위

객체지향 분석 방법론 : 소프트웨어를 개발하기 위한 비즈니스를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해 내는 기법
- 동적 모델링 기법이 사용될 수 있따.
- 데이터와 행위를 하나로 묶어 객체를 정의 내리고 추상화시키는 작업이라 할 수 있다.
- 코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다.

1. Rumbaugh*(럼바우) 방법
- 가장 일반적으로 사용되는 방법
- 분석 활동을 객체 모델, 동적모델, 기능 모델로 나누어 수행하는 방법
- 상태 다이어그램을 사용한다.
- 럼파우 분석기법에서 정보모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 다이어그램을 표시하는 모델링 : 객체
- 기능 모델링에서 자료 흐름도를 주로 사용한다.

2. Booch(부치) 방법
- 미시적, 거시적 개발 프로세스를 모두 사용하는 분석 방법
- 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정리

3. Jacobson 방법
- Use Case를 사용하여 분석

4. Coad와 Yourdon 방법
- E-R 다이어그램을 사용하여 객체의 행위를 모델링
- 연산과 메세지 연결 정의 등의 과정으로 주로 관계를 분석

5. Wirfs-Brock(워프트 브록) 방법
- 분석과 설계간 구분 없음
- 연속적으로 수행

애자일 기법 = Agile : 기민한, 민첩한
: 일정한 주기를 가지고 빠르게 제품을 출시하여 고객의 요구사항, 변화된 환경에 맞게 요구를 더 하고 수정해나가는 탄력적인 방법론을 말한다. 
- 절차와 도구보다 개인과 소통을 중요시한다.
- 소프트웨어가 잘 실행되는데 가치를 둔다.
- 고객과의 피드백을 중요하게 생각한다. 

코드설계 : 데이터를 효율적이고 정확하게 처리하기 위해 부여하는 기호나 숫자의 체계

코드설계 원칙 
1. 간결성
2. 일관성
3. 유연성
4. 명확성

코드설계 방법
1. 순차 코드 : 코드에 일련번호를 부여하는 방법. 예를 들어 학생 번호, 주민등록번호 등이 있다. 순차 코드의 장점은 간단하고 쉽게 부여할 수 있다는 것이고, 단점은 의미가 없고 변화에 취약하다는 것이다.
2. 연상 코드 : 코드에 의미를 부여하는 것. 예를 들어 상품 분류 코드, 국가 코드 등이 있다. 연상 코드의 장점은 의미가 있고 기억하기 쉽다는 것이고, 단점은 길이가 길어지고 중복될 수 있다는 것이다.
3. 블록 코드 : 코드를 여러 부분으로 나누어 각 부분에 의미를 부여하는 방법이다. 예를 들어 ISBN, 우편 번호 등이 있다. 블록 코드의 장점은 의미가 있고 구조화되어 있다는 것이고, 단점은 복잡하고 오류가 발생할 수 있다는 것이다.
4. 표의 숫자 코드 : 표를 이용하여 데이터를 변환하는 방법이다. 예를 들어 아스키 코드 에비시딕 코드 등이 있다. 표의 숫자 코드의 장점은 표준화되어 있고 호환성이 좋다는 것이고, 단점은 표를 참조해야하고 확장성이 낮다는 것이다. -> 중량, 면적, 용량 등의 물리적 수치를 이용하여 만든 코드
 


![image](https://github.com/pointmina/EIP/assets/68779817/98f5badf-4892-435e-b679-12f46315ce37)

CASE(Computer - Aided Software Engineering)
: 소프트웨어 개발 시 사용되는 분석 자동화 도구.. 소프트웨어 개발 과정의 일부나 전체를 자동화하는 도구
- 구조적 기법
- 프로토타이핑 기술
- 정보 저장소 기술

기능
- 그래픽 지원
- 소프트웨어 생명 주기 전반적인 단계의 연결
- 다양한 소프트웨어 개발 모형을 지원
- 모델들 사이의 모순검사 기능
- 모델의 오류검사 기능
- 자료흐름도 작성 기능

XP
- 사용자의 요구사항은 언제든지 변할 수 있다.
- 고객과 직접 대면하여 요구사항을 이야기하기 위해 사용자 스토리(User Story)를 활용할 수 있따.
- 기존의 방법론에 비해 실용성을 강조한 것이라고 볼 수 있다.


XP(eXtreme Programing)의 핵심가치
- 용기
- 존중
- 의사소통
- 피드백
- 단순성

XP의 기본원리 
- Whole Team(전체팀)
- Small Releases(소규모 릴리즈)
- Test-Driven Development(테스트 주도 개발)
- Collective Ownership(집단적인 소유)
- Pair Programming(짝 프로그래밍)
- Design Improvement(디자인 개선) or Refactoring(리팩토링)
  

DBMS 분석 시 고려사항
- 가용성 : 장애 발생 가능성, 안정적인 트랜잭션 처리 능력
- 성능
- 상호 호환성
- 기술 지원
- 구축 비용

럼바우(Rumbaugh)의 객체지향 분석 절차 
객체 모형 -> 동적 모형 -> 기능 모형
- 동정 모델링에서 상태 다이어그램이 활용된다.

DFD(Data Flow Diagram)
- 자료의 출발지와 목적지를 그림으로 표시한 것이다.
- 데이터 흐름도 또는 자료 흐름도 라고도 한다.
- 자료 흐름 그래프 또는 버블 차트라고도 한다.
- 구조적 분석 기법에 이용된다.
- DFD의 요소는 화살표, 원, 사각형, 직선(단선/이중선)으로 표시한다.
- 시간 흐름을 명확하게 표현할 수 없다...

DFD의 구성요소
- 프로세스 : 원
- 데이터 흐름 : 화살표
- 데이터 저장소 : = 모양
- 외부엔티티
- 터미네이터 : 사각형

UML(Umified Modeling Language)
: 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향모델링 언어이다. 즉, 많은 사람들이 모여 작업을 수행하다 보면 같은 대상물을 보고도 서로 다르게 표현하여 의사소통에 문제가 생기는 경우가 있다. 이런 문제를 해결하기 좋은 방법은 공통된 표현법을 만드는 것이다. 
- 기능적 모델은 사용자 측면에서 본 시스템 기능이며, UML에서는 Use Case Diagram을 사용한다.
- 정적 모델은 객체, 속성, 연관관계, 오퍼레이션의 시스템의 구조를 나타내며, UML에서는 Class Diagram을 사용한다.
- 동적 모델은 시스템 내부 동작을 말하며, UML에서는 Sequence Diagram, State Diagram, Activity Diagram을 사용한다. 

1. 사물(Things) : 모델을 구성하는 가장 중요한 기본 요소, 다이어그램 안에서 관계가 형성될 수 있는 대상들을 말한다. 
- 구조사물 : 시스템의 개념적, 물리적 요소를 표현, 클래스, 유스캐이스, 컴포넌트, 노드 등
- 행동사물 : 시작과 공간에 따른 요소들의 행위를 표현, 상호작용, 상태머신 등
- 그룹사물 : 요소들을 그룹으로 만들어 표현, 패키지
- 주해사물 : 부가적인 설명이나 제약조건 등을 표현, 노트

2. 관계(Relationship) : 사물과 사물 사이의 연관성을 표현하는 것
- 연관관계 : 2개 이상의 사물이 서로 관련되어 있음을 표현한다.
- 집합관계 : 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현한다.
- 포함관계 : 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
- 일반화관계 : 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현한다.
- 의존관계 : 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
- 실체화관계 : 사물이 할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계

3. 다이어그램(Diagram) : 사물과 관계를 도형으로 표현한 것

구조적 다이어그램의 종류 :ㅋㅋㅂㅂㄱㅍ
- 클래스 다이어그램
- 객체 다이어그램
- 컴포넌트 다이어그램
- 배치 다이어그램
- 복합체 구조 다이어그램
- 패키지 다이어그램 

나머지는 행위 다이어그램

정적 다이어그램
- 컴포넌트 다이어그램
- 배치 다이어그램
- 패키지 다이어그램

![image](https://github.com/pointmina/EIP/assets/68779817/8d8ef12b-08f5-4b63-b10a-ca6c353f37e6)

요구사항 분석 기법
1. 요구사항 분석
2. 개념 모델링
3. 요구사항 할당
4. 요구사항 협상
5. 정형분석

미들웨어
: 미들과 소프트웨어의 합성어로, 운영체제와 해당 운영체제에서 실행되는 응용 프로그램 사이에서 운영체제가 제공하는 서비스 이외의 추가적인 서비스를 제공하는 소프트웨어이다. 혹은 클라이언트와 서버 간의 통신을 담당하는 소트프웨어이다. 
- 미들웨어는 표준화된 인터페이스를 제공하며 시스템 간의 데이터 교환의 일관성을 보장한다.

미들웨어 종류 : 클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어 
- DB
- RPC : 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어
- MOM
- TP-Monitor
- ORB
- WAS

시퀸스 다이어그램 : 문제 해결을 위한 객체를 정의하고 객체 간의 상호작용 메시지 시퀀스를 흐름에 따라 나타내는 다이어그램

구성요소
- 객체와 생명선
- 활성 박스
- 메시지
- 가드
- 프래그먼트
- 실행

상속(inherutance)
: 코드 재사용
- 자식클래스가 부모클래스의 특징과 기능을 물려받은 것
- 클래스를 상속 받아 수정하여 사용하기 때문에 중복 코드를 줄일 수 있따.
- 부모클래스의 수정으로 모든 자식클래스들도 수정되는 효과

다향성(polymorphism)
: 객체 변경 용이
- 어떤 변수, 메소드가 상황에 따라 다른 결과를 내는 것
- 오버라이딩, 오버로딩

캡슐화(Encapsulation)
: 일반적으로 연관 있는 변수와 함수를 클래스로 묶는 작업을 말한다.
- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
- 구현에 사용된 데이터의 상세 내용을 외부에 감춤
- 정보 은닉 의미 포함
- 인터페이스가 단순화된다.
- 소프트웨어 재사용성이 높아진다.
- 변경 발생 시 오류의 파급효과가 적다.
- 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 들어내는 과정

추상화(Abstraction)
: 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜나가는 것
- 과거 추상화 : 자세한 수행 과정은 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
- 데이터 추상화 : 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
- 제어 추상화 : 이벤트 방생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법
- 자료 추상화
- 과정 추상화
- 제어 추상화



협약에 의한 설계 : 클래스의 명확한 인터페이스 명세를 위해서 선행 조건, 결과 조건, 불변 조건을 기술하는 설계 방법
- 선행 조건 
- 결과 조건
- 불변 조건

객체지향 설계 5원칙 SOLID
![image](https://github.com/pointmina/EIP/assets/68779817/08d27253-3735-4bf8-9c4f-15ea5974e1a9)

1. SRP : 단일 책임 원칙 : 어떤 클래스를 변경해야하는 이유는 오직 하나 뿐이어야한다.
2. OCP : 개방 폐쇄 원칙 : 소프트웨어 앤티티는 확장에 대해서는 열려 있어야 하지만 변경에 있어서는 닫혀 있어야한다.
3. LSP : 리스코르 치환 원칙 : 서브타입은 언제나 자신의 기반타입으로 교체할 수 있어야한다.
4. ISP : 인터페이스 분리 원칙 : 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.
5. DIP : 의존 역전 원칙 : 고차원 모듈은 저차원 모듈에 의존하면 안된다. 

소프트웨어 설계

1. 소프트웨어 아키텍처의 설계
- 소프트웨어 아키텍처는 소프트웨어의 골격이 되는 기본 구조이자, 소프트웨어 구송 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.
- 소프트웨어 개발 시 적용되는 원칙과 지침
- 이해관계자들의 의사소통 도구로 활용된다.

![image](https://github.com/pointmina/EIP/assets/68779817/0f084364-4a4c-402a-b820-dfe2572c2c05)

2. 모듈화
- 소프트웨어의 성능을 향상하거나 시스템의 수정 및 재사용, 유지관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.
- 모듈이란 전체 프로그램의 기능 중에서 특정 기능을 처리할 수 있는 소스 코드를 의미한다.
- 자주 사용되는 계산식이나 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성을 향상한다.
- 모듈의 크기를 너무 작게 나누면 개수가 많아져서 모듈 간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.

3. 추상화
- 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것
- 최소의 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다.

![image](https://github.com/pointmina/EIP/assets/68779817/1f668c47-3d35-4464-bc0b-a5c541235e2d)

4. 단계적 분해
- 하향식 설계 전략으로 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다.
- 추상화의 반복에 의해 세분화된다.
- 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료구조 등 상세한 내역은 가능한 뒤로 미뤄 진행한다.

5. 정보 은닉
- 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
- 어떤 모듈이 소프트웨어 기능을 수행하는데 반드시 필요한 기능이 있어 정보 은닉된 모듈과 커뮤니케이션할 필요가 있을 떄는 필요한 정보만 인터페이스를 통해 주고 받는다.
- 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다. 

자료사전(Data Dictionary)에서 선택의 의미를 나타내는 것은? : []

소프트웨어의 사용자 인터페이스개발시스템(User Interface)이 가져야 할 기능이 아닌 것은?
1. 사용자 입력의 검증
2. 에러처리와 에러 메세지 처리
3. 도움과 프롬프트 제공

요구사항 명세기법

![image](https://github.com/pointmina/EIP/assets/68779817/5cbabff8-965c-48b2-989a-a06ac2462aa8)

정형 명세 기법 : 수학적 모델 기반 모델 기반
- 요구사항을 정확하고 간결하게 표현
- 요구사항에 대한 결과가 작성자에 관계없이 일관성이 잇으므로 완전성 검증이 가능함
- 정형 명세 기법은 비정령 명세기법에 비해 표현이 간결하다.
- VDM, Z, Petri-net, CSP

Z
- 집합론, 논리, 모델기반 명세기법
- 논리를 기반으로한 Calculus 적 표현을 사용하여 여러 특성을 VDM보다 함축적으로 표현
- Z스키마 구조 - **스키마** 이름, 스키마 시그니처, 스키마 술어
- 모듈간의 재사용성이 우수하다
- 스키마간의 연산이 가능

VDM
- 시스템의 비기능적인 요구사항을 제외한 **기능적인 요구사항에만 한정**되어 있어 이와 관련한 기능 요구 명세와 검증설계에 관해 적절한 표기법인 검증 방법을 제공한다.

Petri Net
- **그래프**에 의한 표기법을 제공하며, 병렬 처리를 기술할 때 유한상태기계의 한계성을 극복하도록 고안

비정형 명세 기법
- 상태/기능/객체 중심
- 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성
- 자연어의 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고, 해석이 달라질 수 잇음
- 내용의 이해가 쉬워 의사소통이 용이하다.
- FSM, Decision Table, ER 모델링, SADT

애자일 방법론(Agile : 기민한, 민첩한)
- 일정한 주기를 가지고 빠르게 제품을 출시하여 고객의 요구사항, 변화된 환경에 맞게 요구를 더 하고 수정해나가는 탄력적인 방법론
- XP(익스트림 프로그래밍)
- 스크럼 : 특정 개발 언어나 방법론에 의존하지 않으며, 제품 개발 뿐만 아니라 일반적인 프로젝트 관리에도 사용 가능한 프로세스 프레임워크
- 기능중심 개발
- 프로세스 도구보다는 개인과 상호작용에 더 가치를 둔다.
- 계약 협상보다는 고객과의 협업에 더 가치를 둔다.
- 계획을 따르기보다는 변화에 대응하는 것에 더 가치를 둔다.

소켓
- 인터넷 소켓 또는 네트워크 소켓이라고 부르기도 한다.
- 네트워크로 연결되어 있는 컴퓨터의 통신의 접점에 위치한 통신 객체이다. 네트워크 통신을 위한 프로그램은 소켓을 생성하고, 이 소켓을 통해서 서로 데이터를 교환한다.

프로토타입
- 정보시스템의 미완성 버전 또는 중요한 기능들이 포함되어 있는 시스템의 초기 모델이다.
- 사용자의 모든 요구사항이 정확하게 반영할 때까지 계속해서 보완/개선 한다.

Use Case의 구성요소 간 관계
- 연관 : Use Case와 Actor의 관계를 표현(실선)
- 확장 : 기본 Use Case 수행 시 특별한 조건을 만족할 때 수행함
- 포함 : 시스템의 기능이 별도의 기능을 포함(점선)
- 일반화 : 하위 Use Case/Action 이 상위 Use Case/Actor에게 기능/역할을 상속 받음
- 그룹화 : 여러 개의 Use Case를 단순화하는 방법

시스템
: 하나의 공통적인 목적을 가지고 있는 구성 요소들을 상호 결합해 놓은 유기적인 집합체이다.

시스템의 기본요소
1. 입력
2. 출력
3. 처리
4. 제어
5. 피드백

피드백의 종류
1. 전수피드백
2. 부분 피드백
3. 전략적 피드백
4. 기호 피드밷

유스케이스 다이어그램
: 시스템과 사용자의 상호작용을 다이어그램으로 표현한 것으로 사용자의 관점에서 시스템의 서비스 혹은 기능 및 그와 관련한 외부 요소를 보여주는 것이다.

유스케이스 구성요소
- 시스템 : 만들고자하는 프로그램
- 액터 : 시스템 외부에 있고 시스템과 상호작용을 하는 사람
- 유스케이스 : 사용자 입장에서 바라본 시스템의 기능
- 관계 : 액터와 유스케이스 사이의 의미 있는 관계

아키텍처 패턴

1. 레이어패턴
: 시스템을 계층으로 구분하여 구성하는 고전적 방법 중 하나
- 각각의 서브시스템들이 계층구조를 이룸, 상위 계층 - 서비스 제공자 / 하위 계층 - 클라이언트
    
2. 클라이언트-서버 패턴
: 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
- 사용자가 클라이언트를 통해 서버에 요청, 클라이언트가 응답 받아 사용자에게 제공하는 방식으로 서비스 제공

3. 파이프-필터 패턴
: 데이터 스크림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴
- 재사용성이 좋음, 추가가 쉬워 확장이 용이

4. 모델-뷰-컨트롤러 패턴
: 서브시스템을 3개의 부분으로 구조화하는 패턴
- 모델 : 서브시스템의 핵심 기능과 데이터 보관
- 뷰 : 사용자에게 정보 표시
- 컨트롤러 : 사용자로부터 받은 입력 처리

5. 마스터-슬레이브 패턴
: 마스터 컴포넌트가 지시한 일을 여러 슬레이브 컴포넌트가 병렬처리하여 결과를 취합한다.
- 도중에 몇개의 슬레이브가 고장나도 처리에는 문제가 없다.
- 일반적으로 실시간 시스템에서 사용된다.
- 마스터 프로세스는 일반적으로 연산, 통신, 조정을 책임진다.
- 마스터 프로세스는 슬레이브 프로세스들을 제어할 수 있따.

6. 브로커 패턴
- 클라이언트의 요청을 중간에서 브로커가 적절한 서버로 연결해주는 방식(서버 여러개 = 분산환경 시스템)

7. 피어 투 피어 패턴(P2P)
- 서버와 클라이언트가 서로 역할을 바꿀 수 있는 형태
- 두가지 일을 병렬로 수행하는 멀티스레딩이 특징

8. 이벤트-버스 패턴
- 특정 이벤트를 발생하면 해당 채널(버스)를 구독하고 있는 리스너들이 이벤트를 받아서 처리하는 형식

9. 블랙보드 패턴
- 공유 데이터를 관리하는 블랙보드에 접근하여 원하는 데이터를 찾는 형식(음성인식, 차량식별, 신호해석, 등)

UI 설계 도수
1. 와이어프레임 : 기획 단계의 기초에 제작하는 것, 페이지에 대한 개략적인 레잉아웃이나 UI 등에 대한 뼈대를 설계하는 단계
2. 목업 : 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임보다 좀 더 설계 하면과 유사하게 만든 정적인 형태의 모형, 시각적으로만 구성 요소를 배치하는 것으로 실제로 구현되지 않음
3. 스토리보드 : 와이어프레임에 콘텐츠에 대한 성명, 페이지 간 이동 흐름을 추가한 문서
4. 프로토 타입 : 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
5. 유스 케이스 : 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술

아키텍처 설계 과정
설계 목표 설정 -> 시스템 타입 결정 -> 스타일 적용 및 커마 -> 서브시스템의 기능, 인터페이스 동작 작성 -> 아키텍처 설계 검토

시스템 연계 솔루션
1. FEP(Front End Processor) : 입력되는 데이터를 컴퓨터의 프로세스가 처리하기 전에 미리 처리하여 프로세서가 처리하는 시간을 줄여주는 프로그램이나 하드웨어를 말한다.
2. EAI(Enterprise Application Integration) : 엔터프라이즈의 미들웨어를 인프라로 하여 다양한 이질적 기업환경(애플리케이션, 데이터, 플랫폼 및 네트워크 등)을 통합하여 하나의 시스템으로 관리 운영할 수 있는 유기적인 시스템










   
