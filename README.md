# data_structure

<h2>p73 2.10 클래스</h2>

클래스는(class)는 객체를 찍어내는 틀이고, 객체(object)는 변수와 같이 **자료를 저장하는 프로그램의 구성 요소** 이다.

클래스는 속성을 나타내는 멤버 변수와 동작을 나타내는 멤버함수 또는 매소드로 이루어진다.
ex) 자동차의 색상이나 속도 (속성) => 멤버변수 / 가속, 감속 => 동작 멤버함수

클래스의 첫글자는 대분자로 사용한다.

<h3>생성자</h3>
모든 클래스는 생성자라고 불리는 특별한 멤버 함수를 정의해야 한다.  생성자는 객체가 생성될 때 마다 자동으로 호출되는 함수인데, 객체가 사용할 데이터를 정의하고 초기화한다. 
생성자는 __init__으로 함수 이름이 이미 정해져 있다. 

ex)
class Car :
  def__init__(self,color,speed=0): #생성자 함수
    self.color = color             #데이터 멤버 color 정의 및 초기화
    self.speed = speed             #데이터 멤버 speed 정의 및 초기화

클래스에 생성자가 정의되면 객체를 생성할 수 있다.

car1 = Car('black',1)
car2 = Car('red',120)
car3 = Car('blue',40)

self의 역할은 자동으로 메소들을 호출한 객체를 참조하도록 처리한다.

ex)

class Car:
  def speedUp(self) : self.speed+=10
  def speedDown(self) : self.speed-=10

이런식으로도 사용가능


<h2>p.91 리스트와 집합</h2>

리스트란? 가장 자유로운 선형 자료구조이다.

리스트 또는 선형 리스트는 항목들이 차례대로 나열되어 있는 선형 자료 구조이다. 
리스트의 항목들은 순서 또는 위치를 가진다. 항목들 사이에 순서가 있다는 점에서 집합과는 다르다.

리스트는 배열구조와 연결된 구조로 구현할 수 있다.

1. 배열구조(array)
- 같은 자료형의 데이터를 한꺼번에 만들 때 사용한다.
- 항목들이 반드시 메모리에서 연속적인 공간에 위치한다.
- 배열이 아무리 크더라도 k번째 항목을 바로 찾아갈 수 있다 => 항목 **접근**의 시간 복잡도가 O(1)이다.
- 용량 변경이 어렵다.
- 배열의 중간에 데이터를 넣고 빼는 등의 연산이 비효율적이다. : **삽입 삭제**시 O(n) -> 첫번째에 삽입하면 n개를 움직여야한다.

2. 연결된 구조(linked structure)
- 항목들을 줄로 연결하여 표현하는 방법이다.
- 인접한 항목이라고 인접한 위치에 있다는 보장은 없다.
- 모든 항목들은 링크를 이용해 다음 항목의 위치만을 알고 있따.
- 이 떄문에 k번째 항목의 위치를 바로 계산할 수 없다. O(n)
- 킹치만 삽입삭제시에는 주소만 바꿔주면 되기 때문에 간단하다.

<h3>파이썬 리스트의 시간 복잡도</h3>

append()연산의 시간 복잡도 
- 남은 용량이 있다면 맨뒤에 삽입만 하면 된다. -> O(1)
- 그렇지만 없다면 내부적으로 새로운 배열을 할당하고 기존 항목들을 모두 복사해야 한다. -> 최소 O(n)

insert()연산의 시간 복잡도 : O(n)

pop()연산의 시간 복잡도 : O(n)
- s.pop(0)으로 첫번째 값을 삭제하려면 모든 항목들을 앞으로 당겨야 한다.

결론 => 파이썬 리스트에서 후단 삽입이나 삭제는 효율적이지만 중간이다 전단에서 항목을 빼는 경우는 **비효울적**이다!
       그래서 삽입은 가능한 한 append() 삭제는 A.pop(-1)을 사용하는 것이 좋다 -1은 리스트의 맨 마지막 항목을 말한다.

<h3>배열로 구현한 리스트</h3>

items = []

1. insert(pos,elem) 삽입 연산 -> O(1)
  def insert(pos,elem):
    items.insert(pos,elem)

2. delete(pos) 삭제연산 -> O(n)
   def delete(pos):          #pos 위치에 있는 요소를 꺼내고 반환한다.
     return items.pop(pos)

3. getEntry(pos) 항목접근 연산 -> O(1)
   def getEntry(pos) : return items[pos]

4. isEmpty() 공백 상태 검사
   def isEmpty() :
     if len(items) == 0:
       return True
     else :
       return False

<h2>p.113 집합</h2>

집합이란? 원소의 중복을 허용하지 않고 순서도 있지 않는다. 

- Set() : 비어 있는 새로운 집합을 만든다.
- size() : 집합의 원소의 개수를 반환한다.
- contains(e) : 집합이 원소 e를 포함하는지를 검사하고 반환한다. -> O(n) 순차탐색
- insert(e) : 새로운 원소 e를 삽입한다. 이미 e가 있다면 삽입하지 못한다. -> O(n) 순차탐색 왜냐? 중복된게 있는지 처음부터 봐야하거든 ㅋㅋ

- 합집합,교집합,차집합 = O(n^2) 교차해서 중복검사를 해야하기 때문...!
- ArraySet.py 파일 차집합 합집합 교집합 한번 보기!
- .....

  

  
